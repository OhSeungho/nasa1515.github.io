---
layout: post
title: "[Kubernetes] - 쿠버네티스의 개념, PODS"
author: Lee Wonseok
categories: Kubernetes
date: 2020-08-17 09:36
comments: true
cover: "/assets/kubernets.jpg"
tags: Kubernetes
---



#  KUBERNETES - 쿠버네티스의 개념 정리, PODS    

**머리말**  
이전 포스트에서 드디어 GCP 인스턴스 기반의 k8s 클러스터 환경을 구축했다.  
이번 포스트에서는 이번에 간단하게 포스트해서 정리했지만  
실제 실습을 들어가기전 전체적인 개념에 대해서 다시 한번 정리하고  
쿠버네티스의 PODS에 대해서 포스트한다.


---

**참고  :**  [조대협님 블로그](https://bcho.tistory.com/1256)
 
---

**목차**

- [개념 정리](#a1)
- [구성 (Install)](#a2)



---

## 개념정리   <a name="a1"></a>


* ### **오브젝트**  
    **쿠버네티스를 이해하기 위해 가장 중요한 부분이 ``오브젝트``이다.**  
    **가장 ``기본적인 구성단위``가 되는 ``기본 오브젝트(Basic object)``**  
    **``기본 오브젝트(Basic object)`` 를 ``생성``하고 ``관리``하는 추가적인 기능을 가진 ``컨트롤러(Controller)``**  
    **이러한 오브젝트의 ``스펙(설정)``이외에 추가정보인 ``메타 정보``들로 구성이 된다고 보면 된다.** 

* ### **``오브젝트 스펙 (Object Spec)``**   
    **오브젝트들은 모두 오브젝트의 특성 (설정정보)을 기술한 오브젝트 스펙 (Object Spec)으로 정의가 되고,  
    커맨드 라인을 통해서 오브젝트 생성 시 인자로 전달하여 정의를 하거나  
    또는 ``yaml``이나 ``json`` 파일로 ``스펙을 정의``할 수 있다.** 

* ### **``기본 오브젝트 (Basic Object)``**  
    **쿠버네티스에 의해서 배포 및 관리되는 가장 기본적인 오브젝트는  
    컨테이너화되어 배포되는 애플리케이션의 워크로드를 기술하는 오브젝트로 4가지가 있다.**   
    
    * **Pod : 컨테이너화된 애플리케이션**
    * **Service : 로드밸런서**
    * **Volume : 디스크**
    * **Namespace : 패키지**

---


* ### **``Pod``**  
    **Pod 는 쿠버네티스에서 ``가장 기본적인 배포 단위``로, 컨테이너를 포함하는 단위이다.**

    **k8s의 특징중의 하나는 컨테이너를 하나씩 배포하는 것이 아니라  
    Pod 라는 단위로 배포하는데, Pod는 하나 이상의 컨테이너를 포함한다.**



    * **간단한 Pod를 정의한 오브젝트 스펙이다**

        ```
        apiVersion: v1
        kind: Pod
        metadata:
        name: nginx
        spec:
        containers:
        - name: nginx
            image: nginx:1.7.9
            ports:
            - containerPort: 8090
        ```


    * **``apiVersion`` :  이 스크립트를 실행하기 위한 쿠버네티스 API 버전 (보통 v1을 사용한다)**

    * **``kind`` : 리소스의 종류를 정의, (Pod)**

    * **``metadata`` : 리소스의 각종 메타 데이타 정의**  
    **``라벨``이나 ``리소스의 이름`` 등 각종 메타데이타를 넣는다.**  

    * **``spec`` : 리소스에 대한 ``상세한 스펙``을 정의한다.**
        * **Pod는 컨테이너를 가지고 있기 때문에, container 를 정의**  
        * **이름은 ``nginx``** 
        * **``도커 이미지 nginx:1.7.9`` 를 사용**  
        * **``컨테이너 포트 8090을 오픈``한다.**

---

**도대체 왜 Pod 안에 한개 이상의 컨테이너를 가지고 있음에도**  
**개별적으로 하나씩 컨테이너를 배포하지 않고**  
**여러개의 컨테이너를 Pod 단위로 묶어서 배포할까?**



* ### **Pod는 다음과 두가지 특징을 가지고 있기 때문이다.**  

    * **``Pod 내의 컨테이너는 IP와 Port를 공유한다.``**   
    
        ``두 개의 컨테이너``가 ``하나의 Pod를 통해서 배포``되었을때  
        localhost를 통해서 통신이 가능하다.  
        
        컨테이너 ``A가 8080``, 컨테이너 ``B가 7001``로 배포가 되었을 때  
        ``B -> A``를 호출 할 때 ``localhost:8080 으로 호출``하면 되고  
        ``A -> B``를 호출 할 때는 ``localhost:7001로 호출``이 가능하다. 

    * **``Pod 내에 배포된 컨테이너간에는 디스크 볼륨을 공유할 수 있다.``**   
    
        **요즘 APP은 실행할때 APP만 올라가는것이 아니라  
        ``Reverse proxy``, ``로그 수집기``등 다양한 주변 솔루션이 같이 배포 된다.**    
    
        **``APP(Tomcat, node.js)``와 로그 수집기를 다른 컨테이너로 배포할 경우  
        일반적인 경우 컨테이너에 의해서 ``파일 시스템이 분리``되기 때문에  
        로그 수집기가 APP 컨테이너의 로그파일을 읽는 것이 불가능 하다.**

        **하지만 쿠버네티스의 경우  
        하나의 Pod 내에서는 컨테이너들끼리 볼륨을 공유할 수 있기 때문에  
        다른 컨테이너의 파일을 읽어올 수 있다.**

---

* ### **``Volume``** 

    **간단하게 요약해서 볼륨은 외장디스크라고 이해하면 된다.**

    **자세한 내용은 -> [볼륨 정리](https://nasa1515.github.io/kubernetes/2020/08/18/Kubernetic.html) 에 정리된 포스트를 올려놓았다.**

---

* ### **``Service``** 

    **``Pod``와 ``볼륨``을 이용하여, ``컨테이너들을 정의``한 후에, Pod를 서비스로 제공할때**  
     
    **분산환경에서는 하나의 Pod로 서비스 하는 경우는 드물고  
    여러 Pod를 ``로드밸런서를 이용해서 하나의 IP와 포트``로 묶어 서비스를 제공한다.**

    **Pod의 경우에는 동적으로 생성 되고, 장애가 생기면 자동으로 재시작 되며 IP가 바뀌기 때문에  
    ``로드밸런서``에서 Pod의 목록을 지정할 때는 IP주소를 이용하는 것은 어렵다.  
    또 ``오토 스케일링``으로 인하여 ``Pod 가 동적으로 추가 또는 삭제``되기 때문에  
    이렇게 추가/삭제된 Pod 목록을 로드밸런서가 유연하게 선택해 줘야 한다.**
     
    **그래서 사용하는 것이 ``라벨(label)``과 ``라벨 셀렉터(label selector)`` 라는 개념이다.**

    * **``라벨 셀렉터(label selector)`` : 어떤 Pod를 서비스로 묶을 것인지 정의**  
     
        **각 Pod를 생성할때 ``메타데이타 정보 부분``에 ``라벨을 정의``할 수 있다.  
    서비스는 라벨 셀렉터에서 특정 라벨을 가지고 있는 Pod만 선택하여 서비스에 묶게 된다.**


        ![스크린샷, 2020-08-25 12-28-23](https://user-images.githubusercontent.com/69498804/91119584-7d6a6e80-e6ce-11ea-805b-199d8c7e1e24.png)

        **그림설명 : 라벨이 ``“myapp”``인 서비스만 분류해 서비스에 넣는다.  
        분류된 Pod 간 ``로드밸런싱``을 통하여 외부로 서비스를 제공**

---

* **이를 스펙으로 정의해보자**


    ```
    kind: Service
    apiVersion: v1
    metadata:
    name: my-service
    spec:
    selector:
        app: myapp
    ports:
    - protocol: TCP
        port: 80
        targetPort: 9376
    ```


    * **``kind`` : Service로 지정**
    * **``apiVersion`` : v1으로 정의**
    * **``metadate-name`` : my-service (서비스의 이름)**
    * **``spec`` : 서비스에 대한 스펙을 정의**
    * **``selector`` : 라벨 = ``app:myapp``인 Pod 만을 선택해서 분류**

    * **``ports``**  
    **``protocol`` : TCP**  
    **``port`` : 80 포트로 서비스** 
    **``targetPort`` : 80 포트 요청을 컨테이너의 9376 포트로 연결해 제공한다** 

---


Name space
네임스페이스는 한 쿠버네티스 클러스터내의 논리적인 분리단위라고 보면 된다.

Pod,Service 등은 네임 스페이스 별로 생성이나 관리가 될 수 있고, 사용자의 권한 역시 이 네임 스페이스 별로 나눠서 부여할 수 있다.

즉 하나의 클러스터 내에, 개발/운영/테스트 환경이 있을때, 클러스터를 개발/운영/테스트 3개의 네임 스페이스로 나눠서 운영할 수 있다. 네임스페이스로 할 수 있는 것은

 사용자별로 네임스페이스별 접근 권한을 다르게 운영할 수 있다.

 네임스페이스별로 리소스의 쿼타 (할당량)을 지정할 수 있다. 개발계에는 CPU 100, 운영계에는 CPU 400과 GPU 100개 식으로, 사용 가능한 리소스의 수를 지정할 수 있다. 

네임 스페이스별로 리소스를 나눠서 관리할 수 있다. (Pod, Service 등)



주의할점은 네임 스페이스는 논리적인 분리 단위이지 물리적이나 기타 장치를 통해서 환경을 분리(Isolation)한것이 아니다. 다른 네임 스페이스간의 pod 라도 통신은 가능하다. 

물론 네트워크 정책을 이용하여, 네임 스페이스간의 통신을 막을 수 있지만 높은 수준의 분리 정책을 원하는 경우에는 쿠버네티스 클러스터 자체를 분리하는 것을 권장한다.



출처: https://bcho.tistory.com/1256 [조대협의 블로그]

출처: https://bcho.tistory.com/1256 [조대협의 블로그]

