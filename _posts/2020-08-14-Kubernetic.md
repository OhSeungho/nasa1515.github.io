---
layout: post
title: "[Kubernetes] - 쿠버네티스란?"
author: Lee Wonseok
categories: Kubernetes
date: 2020-08-14 09:36
comments: true
cover: "/assets/kubernets.jpg"
tags: Kubernetes
---



#  KUBERNETES - 첫걸음

**머리말**  
 쿠버네티스.  
 이름만 많이 들어보고 신적으로 추앙받는 기술이라고만 들었다.  
 하지만 온프레미스 경험만 가지고 있는 나는 아무것도 알지 못한다.    
 아마도 포스트를 작성하면서 조금씩 익숙해질 것이라고 생각한다.  
 마지막 포스트를 쓸 때 쯤에는 중급은 아니더라도 초급정도의 스킬은 가지고 있었으면 싶다.  

 
---

**목차**

- [쿠버네티스란??](#a1)
- [쿠버네티스의 배포 방식](#a2)
- [NAMESPACE & LABEL](#a3)
- [Auto Scaling](#a4)
- [쿠버네티스의 기본 로직, 및 개념](#a5)
- [아키텍처](#a6)

- [아키텍처](#a6)
- [아키텍처](#a6)


---



## 쿠버네티스란?? <a name="a1"></a>

  

![](https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/kubernetes-logo.png)


* **쿠버네티스는 컨테이너를 쉽고 빠르게 ``배포/확장하고 관리를 자동화``해주는 오픈소스 플랫폼입니다.**  

* **보통 k8s 또는 큐브 (kube) 라고 줄여서 부릅니다.**

* **현재는 단순한 컨테이너 플랫폼이 아닌 ``마이크로서비스``, ``클라우드 플랫폼``을 지향하고  
컨테이너로 이루어진 것들을 손쉽게 담고 관리할 수 있는 그릇 역할을 합니다.  
서버리스, CI/CD, 머신러닝 등 다양한 기능이 쿠버네티스 플랫폼 위에서 동작합니다.**

---
## 대표적인 쿠버네티스의 기능들 

---

### 쿠버네티스의 배포 방식 <a name="a2"></a>
![](https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/workload.png)

* **컨테이너와 관련된 많은 예제가 ``웹(프론트엔드+백엔드)`` 애플리케이션을 다루고 있지만  
실제 세상엔 더 다양한 형태의 애플리케이션이 있습니다.  
쿠버네티스는 ``Deployment``, ``StatefulSets``, ``DaemonSet``, ``Job``, ``CronJob``등 다양한 배포 방식을 지원합니다.**  

- **``Deployment``는 새로운 버전의 애플리케이션을 다양한 전략으로 무중단 배포할 수 있습니다.** 
* **``StatefulSets``은 실행 순서를 보장하고 호스트 이름과 볼륨을 일정하게  
사용할 수 있어 순서나 데이터가 중요한 경우에 사용할 수 있습니다.** 

* **``DaemonSet``은 로그나 모니터링 등 모든 노드에 설치가 필요한 경우에 사용 할 수 있습니다.**

* **``Job, CronJob``을 이용해 배치성 작업을 할 수도 있습니다.**

---

### CLOUD 지원

![스크린샷, 2020-08-19 18-16-09](https://user-images.githubusercontent.com/69498804/90616176-12411800-e248-11ea-8e9e-b79e49051a66.png)

* **쿠버네티스는 부하에 따라 자동으로 서버를 늘리는 기능 ``AutoScaling``을 가지고 있으며**  
* **IP를 할당받아 로드밸런스LoadBalancer로 사용할 수 있습니다.** 

* **외부 스토리지를 컨테이너 내부 디렉토리에 마운트하여 사용하는 것도 가능한데  
이를 위해 클라우드 별로 적절한 API를 사용하는 모듈이 필요합니다.**

* **쿠버네티스는 ``Cloud Controller``를 이용하여 클라우드 연동을 손쉽게 확장할 수 있습니다.**  
**``AWS, GCP, AZURE``는 물론 ``다양한 모듈``을 제공하여  
관리자는 동일한 설정 파일을 서로 다른 클라우드에서 동일하게 사용할 수 있습니다.**

---

### NAMESPACE & LABEL <a name="a3"></a>

![스크린샷, 2020-08-20 09-42-17](https://user-images.githubusercontent.com/69498804/90703714-722bd300-e2c9-11ea-927f-e4e2e4fdc719.png)

* **쿠버네티스에서는 1개의 클러스터를 ``논리적으로 구분``하여 사용할 수 있습니다.** 

* **하나의 클러스터에 다양한 프레임워크와 애플리케이션을 설치하기 때문에  
기본(system, default)외에 여러 개의 네임스페이스를 사용하는 것이 당연합니다.**   

* **더 세부적으로 ``라벨 기능``을 적극적으로 사용하여 유연하고, 확장성 있게 리소스를 관리할 수 있습니다.**

---

### Auto Scaling <a name="a4"></a>  




* **k8s는 ``CPU``, ``memory`` 사용량에 따른 확장은 기본이고 현재 접속자 수와 같은 값을 사용할 수도 있습니다.**  

**총 세개의 방식이 대표적인데 아래와 같습니다.**  

* **``Horizontal Pod Autoscaler(HPA)`` : 컨테이너의 개수를 조정**
![스크린샷, 2020-08-20 09-47-14](https://user-images.githubusercontent.com/69498804/90703962-23326d80-e2ca-11ea-934d-86b32cfdd145.png)

* **``Vertical Pod Autoscaler(VPA)``: 컨테이너의 리소스 할당량을 조정** 
![스크린샷, 2020-08-20 09-50-15](https://user-images.githubusercontent.com/69498804/90704099-8f14d600-e2ca-11ea-9e20-1cd1837fa9b2.png)

* **``Cluster Autosclaer(CA)`` : 서버 개수(노드 수) 를 조정** 
---

### 쿠버네티스의 단점  

* **컨테이너라는 개념조차도 처음 접해보는 나에겐 ``쿠버네티스``는 복잡하고 초반 개념을 이해하기 어렵다.**

* **``YAML 설정 파일``은 매우 많고 클러스터를 만드는 것도 쉽지 않다**  

* **즉 오래동안 수련하지 않는 사람을 제외한 초기사용자에겐 진입장벽이 높다**


---

## 쿠버네티스의 기본 로직, 및 개념 <a name="a5"></a>  


* **``Desired State``**

    ![스크린샷, 2020-08-20 09-59-42](https://user-images.githubusercontent.com/69498804/90704590-e10a2b80-e2cb-11ea-95dd-9553e597fd69.png)

* **``k8s``에서 가장 중요한 것은 ``desired state`` - ``원하는 상태`` 라는 개념이라고 합니다.**  

* **``원하는 상태``라 함은 관리자가 원하는 환경을 의미하고  
    구체적으로는 몇대의 웹서버가 떠 있으면 좋은지, 몇 번 포트를 사용하길 원하는지 등을 말합니다.**

* **k8s는 복잡한 작업을 하지만 자세히 들여다보면 ``현재 상태 (current state)``를 모니터링하면서  
관리자가 설정한 상태를 유지하려 내부적으로 작업을 하는 로직을 가지고 있습니다.**

* **이 개념 때문에 관리자가 배포할 때 직접적인 동작을 명령하지 않고 상태를 선언하는 방식을 사용합니다.**

* **예를 들어 “nginx 컨테이너를 실행해줘. 그리고 80 포트로 오픈해줘라는 것은”**  

    * **``명령(imperative)`` :  nginx 컨테이너 실행, 80포트로 서비스 (현재 상태 변경)**
    * **``선언(declarative)`` : 80 포트를 오픈한 nginx 컨테이너를 1개 유지해**


* **말로 풀어쓰니깐 약간 이해가 안되는데 아래의 ``CLI`` 명령을 보면 이해가 될 것이다.**

    ```
    $ docker run                    # 명령 (imperative)
    $ kubectl create 
    # 상태 생성
    ```

    **k8s의 ``핵심은 상태``입니다.  
    쿠버네티스를 사용하려면 어떤 상태가 있고 어떻게 상태를 선언하는지를 아는 것이 가장 중요합니다**

---

## **아키텍처** <a name="a6"></a>  

* **컨테이너는 아주 심플하고 우아하게 동작합니다.**  

* **즉 ``run``을 하면 실행되고 ``stop``을 하면 멈춥니다.**
* **``서버-클라이언트`` 구조를 안다면 컨테이너를 관리하는 에이전트를 만들고  
중앙에서 ``API``를 사용해 원격으로 관리하는 로직을 그릴 수 있을 것입니다.**


    ![스크린샷, 2020-08-20 10-16-16](https://user-images.githubusercontent.com/69498804/90705561-31828880-e2ce-11ea-9b8b-5e6c4d725632.png)

* **ks8 또한 ``Master``에 ``API 서버와 상태 저장소``를 두고 각 ``Node``의 ``에이전트(kubelet)``와 통신하는 구조입니다.**  

---

### **마스터 - 노드 구조**
![스크린샷, 2020-08-20 10-21-31](https://user-images.githubusercontent.com/69498804/90705892-ecab2180-e2ce-11ea-8226-f235801c05ab.png)


* **k8s는 ``전체 클러스터를 관리``하는 ``마스터``와 ``컨테이너가 배포``되는 ``노드``로 구성되어 있습니다.**  

* **모든 명령은 ``마스터의 API 서버를 호출``하고 노드는 마스터와 통신하면서 필요한 작업을 수행합니다.**  

* **특정 노드에 명령하거나 로그를 조회할 때도 노드에 직접 명령하는 게 아닌  
 마스터에 명령을 내리고 마스터가 노드에 접속하여 대신 결과를 응답합니다.**

### **Master**  

* **``MASTER``는 다양한 모듈이 확장성을 고려하여 기능별로 쪼개져 있는 것이 특징 입니다.**  

* **그러다 보니 보안 설정에 심혈을 기울여야 합니다.**
* **마스터 서버 장애시 클러스터를 관리할 수 없기 때문에  
보통 여러대로 구성하여 안정성을 높입니다.**  


### **Node**

* **``NODE``는 ``MASTER``와 통신하면서 필요한 Pod을 생성하고 네트워크와 볼륨을 설정합니다.**  

* **``실제 컨테이너들이 생성되는 곳``으로 거의 수천대로 확장할 수 있습니다.**  
* **``추가적으로 라벨기능``을 사용하게되면  
각각의 서버에 라벨을 붙여 사용목적(GPU 특화, SSD 서버 등)을 정의할 수 있습니다.**

### **Kubectl**

* **API 서버는 json 또는 protobuf 형식을 이용한 http 통신을 지원합니다.**

* **보통 kubectl이라는 명령행 도구를 사용합니다.  (매우 편함!!)**

---